use crate::source::state::PotState;
use crate::verifier::PotVerifier;
use ab_core_primitives::pot::{PotCheckpoints, PotSeed, SlotDuration, SlotNumber};
use ab_proof_of_time::PotError;
use futures::SinkExt;
use futures::channel::mpsc;
use futures::executor::block_on;
use rclite::Arc;
use std::num::NonZeroU32;
use std::thread::sleep;
use std::time::Instant;
use tracing::{debug, trace};

/// Poof generated by timekeeper
#[derive(Debug, Copy, Clone)]
pub struct TimekeeperProof {
    /// Slot number
    pub slot: SlotNumber,
    /// Proof of time seed
    pub seed: PotSeed,
    /// Iterations per slot
    pub slot_iterations: NonZeroU32,
    /// Proof of time checkpoints
    pub checkpoints: PotCheckpoints,
}

/// Timekeeper source
#[derive(Debug)]
#[must_use = "Doesn't do anything unless run() method is called"]
pub struct Timekeeper {
    state: Arc<PotState>,
    pot_verifier: PotVerifier,
    proof_sender: mpsc::Sender<TimekeeperProof>,
    slot_duration: SlotDuration,
}

impl Timekeeper {
    /// Create a new timekeeper source
    pub fn new(
        state: Arc<PotState>,
        pot_verifier: PotVerifier,
        slot_duration: SlotDuration,
    ) -> (Self, mpsc::Receiver<TimekeeperProof>) {
        let (proof_sender, proof_receiver) = mpsc::channel(1);

        (
            Self {
                state,
                pot_verifier,
                proof_sender,
                slot_duration,
            },
            proof_receiver,
        )
    }

    /// Run timekeeper until receiver returned from constructor is dropped.
    ///
    /// Must be running on a dedicated high-frequency CPU core.
    pub fn run(self) -> Result<(), PotError> {
        let Self {
            state,
            pot_verifier,
            mut proof_sender,
            slot_duration,
        } = self;

        Self::try_debug_run(&state, &pot_verifier, &mut proof_sender, slot_duration)?;

        let mut next_slot_input = state.next_slot_input();

        loop {
            trace!(
                "Proving for slot {} with {} iterations",
                next_slot_input.slot, next_slot_input.slot_iterations
            );
            let checkpoints =
                ab_proof_of_time::prove(next_slot_input.seed, next_slot_input.slot_iterations)?;

            let proof = TimekeeperProof {
                seed: next_slot_input.seed,
                slot_iterations: next_slot_input.slot_iterations,
                slot: next_slot_input.slot,
                checkpoints,
            };

            pot_verifier.inject_verified_checkpoints(
                next_slot_input.seed,
                next_slot_input.slot_iterations,
                checkpoints,
            );

            next_slot_input = state
                .try_extend(
                    next_slot_input,
                    next_slot_input.slot,
                    checkpoints.output(),
                    None,
                )
                .unwrap_or_else(|next_slot_input| next_slot_input);

            if let Err(error) = proof_sender.try_send(proof)
                && let Err(error) = block_on(proof_sender.send(error.into_inner()))
            {
                debug!(%error, "Couldn't send proof, the channel is closed");
                return Ok(());
            }
        }
    }

    /// A special version of [`Self::run()`] designed for debug purposes.
    ///
    /// It is used when the specified number of iterations is way too low for slot duration, in
    /// which case artificial delay is applied to maintain slot duration at approximately specified
    /// rate. This allows debugging things without burning a full CPU core at all times.
    #[inline(never)]
    fn try_debug_run(
        state: &Arc<PotState>,
        pot_verifier: &PotVerifier,
        proof_sender: &mut mpsc::Sender<TimekeeperProof>,
        slot_duration: SlotDuration,
    ) -> Result<(), PotError> {
        let mut next_slot_input = state.next_slot_input();

        let delay = {
            let start = Instant::now();
            ab_proof_of_time::prove(next_slot_input.seed, next_slot_input.slot_iterations)?;
            let duration = start.elapsed();

            if duration.is_zero() || duration > slot_duration.as_duration() / 2 {
                // Either can't identify or relatively fast
                return Ok(());
            }

            slot_duration.as_duration() - duration
        };

        loop {
            trace!(
                "Proving for slot {} with {} iterations",
                next_slot_input.slot, next_slot_input.slot_iterations
            );
            let checkpoints =
                ab_proof_of_time::prove(next_slot_input.seed, next_slot_input.slot_iterations)?;

            let proof = TimekeeperProof {
                seed: next_slot_input.seed,
                slot_iterations: next_slot_input.slot_iterations,
                slot: next_slot_input.slot,
                checkpoints,
            };

            pot_verifier.inject_verified_checkpoints(
                next_slot_input.seed,
                next_slot_input.slot_iterations,
                checkpoints,
            );

            next_slot_input = state
                .try_extend(
                    next_slot_input,
                    next_slot_input.slot,
                    checkpoints.output(),
                    None,
                )
                .unwrap_or_else(|next_slot_input| next_slot_input);

            if let Err(error) = proof_sender.try_send(proof)
                && let Err(error) = block_on(proof_sender.send(error.into_inner()))
            {
                debug!(%error, "Couldn't send proof, the channel is closed");
                return Ok(());
            }

            // Artificial delay
            sleep(delay);
        }
    }
}
