use crate::source::state::PotState;
use crate::verifier::PotVerifier;
use ab_core_primitives::pot::{PotCheckpoints, PotSeed, SlotNumber};
use ab_proof_of_time::PotError;
use futures::SinkExt;
use futures::channel::mpsc;
use futures::executor::block_on;
use rclite::Arc;
use std::num::NonZeroU32;
use tracing::{debug, trace};

/// Poof generated by timekeeper
#[derive(Debug, Copy, Clone)]
pub struct TimekeeperProof {
    /// Slot number
    pub slot: SlotNumber,
    /// Proof of time seed
    pub seed: PotSeed,
    /// Iterations per slot
    pub slot_iterations: NonZeroU32,
    /// Proof of time checkpoints
    pub checkpoints: PotCheckpoints,
}

/// Timekeeper source
#[derive(Debug)]
#[must_use = "Doesn't do anything unless run() method is called"]
pub struct Timekeeper {
    state: Arc<PotState>,
    pot_verifier: PotVerifier,
    proof_sender: mpsc::Sender<TimekeeperProof>,
}

impl Timekeeper {
    /// Create a new timekeeper source
    pub fn new(
        state: Arc<PotState>,
        pot_verifier: PotVerifier,
    ) -> (Self, mpsc::Receiver<TimekeeperProof>) {
        let (proof_sender, proof_receiver) = mpsc::channel(1);

        (
            Self {
                state,
                pot_verifier,
                proof_sender,
            },
            proof_receiver,
        )
    }

    /// Run timekeeper until receiver returned from constructor is dropped.
    ///
    /// Must be running on a dedicated high-frequency CPU core.
    pub fn run(self) -> Result<(), PotError> {
        let Self {
            state,
            pot_verifier,
            mut proof_sender,
        } = self;

        let mut next_slot_input = state.next_slot_input();

        loop {
            trace!(
                "Proving for slot {} with {} iterations",
                next_slot_input.slot, next_slot_input.slot_iterations
            );
            let checkpoints =
                ab_proof_of_time::prove(next_slot_input.seed, next_slot_input.slot_iterations)?;

            let proof = TimekeeperProof {
                seed: next_slot_input.seed,
                slot_iterations: next_slot_input.slot_iterations,
                slot: next_slot_input.slot,
                checkpoints,
            };

            pot_verifier.inject_verified_checkpoints(
                next_slot_input.seed,
                next_slot_input.slot_iterations,
                checkpoints,
            );

            next_slot_input = state
                .try_extend(
                    next_slot_input,
                    next_slot_input.slot,
                    checkpoints.output(),
                    None,
                )
                .unwrap_or_else(|next_slot_input| next_slot_input);

            if let Err(error) = proof_sender.try_send(proof)
                && let Err(error) = block_on(proof_sender.send(error.into_inner()))
            {
                debug!(%error, "Couldn't send proof, the channel is closed");
                return Ok(());
            }
        }
    }
}
